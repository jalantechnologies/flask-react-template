#!/usr/bin/env python3

import glob
import json
import os
import re
import subprocess
import sys
import time

DRY_RUN = False

def run_command(cmd, check=True, silent=False, use_shell=False):
    """Run command with proper error handling"""
    if DRY_RUN:
        # Format command for display
        cmd_str = ' '.join(cmd) if isinstance(cmd, list) else cmd
        print(f"  [DRY RUN] Would run: {cmd_str}")
        class MockResult:
            returncode = 0
            stdout = ""
            stderr = ""
        return MockResult()
    
    if use_shell:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    else:
        # Use list format to prevent command injection
        result = subprocess.run(cmd, capture_output=True, text=True)
    if check and result.returncode != 0:
        if not silent:
            cmd_str = ' '.join(cmd) if isinstance(cmd, list) else cmd
            print(f"‚úó Error running: {cmd_str}")
            if result.stderr:
                print(f"  {result.stderr}")
        sys.exit(1)
    return result

def replace_in_file(file_path, replacements):
    """Replace text in file using Python (cross-platform)"""
    if not os.path.exists(file_path):
        return False
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        original = content
        for old, new in replacements:
            content = content.replace(old, new)
        
        if content != original:
            if DRY_RUN:
                print(f"  [DRY RUN] Would update {file_path}")
                return True
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return True
        return False
    except Exception as e:
        print(f"‚úó Error updating {file_path}: {e}")
        return False

def validate_project_name(project_name):
    """Validate project name for GitHub compatibility"""
    if not project_name:
        return False, "Project name cannot be empty"
    if len(project_name) > 100:
        return False, "Project name too long (max 100 characters)"
    if not re.match(r'^[a-zA-Z0-9._-]+$', project_name):
        return False, "Project name contains invalid characters"
    if project_name.startswith('.') or project_name.endswith('.') or '..' in project_name:
        return False, "Project name cannot start/end with dot or contain consecutive dots"
    return True, None

def check_requirements():
    """Check if required tools are available and gh is authenticated"""
    tools = {'git': 'Git version control', 'gh': 'GitHub CLI', 'npm': 'Node.js package manager'}
    missing = []
    for tool, info in tools.items():
        # Use 'where' on Windows, 'which' on Unix
        check_cmd = ['where', tool] if sys.platform == 'win32' else ['which', tool]
        if run_command(check_cmd, check=False, silent=True, use_shell=False).returncode != 0:
            missing.append((tool, info))
    if missing:
        print("‚úó Missing required tools:")
        for tool, info in missing:
            print(f"  - {tool}: {info}")
        sys.exit(1)
    # Verify GitHub CLI is authenticated
    auth_result = run_command(['gh', 'auth', 'status'], check=False, silent=True, use_shell=False)
    if auth_result.returncode != 0:
        print("‚úó GitHub CLI is not authenticated. Run 'gh auth login' to authenticate.")
        sys.exit(1)

def get_replacement_patterns(project_name):
    """Generate all replacement patterns for project name"""
    snake = project_name.replace('-', '_')
    camel = ''.join(word.capitalize() for word in project_name.split('-'))
    return [
        ('flask-react-template', project_name.lower()),
        ('Flask React Template', project_name),
        ('FLASK-REACT-TEMPLATE', project_name.upper()),
        ('flask_react_template', snake),
        ('FlaskReactTemplate', camel),
        ('flaskReactTemplate', camel[0].lower() + camel[1:]),
    ]

def update_package_json(project_name):
    """Update package.json with new project name"""
    print(f"üì¶ Updating package.json...")
    try:
        with open('package.json', 'r') as f:
            data = json.load(f)
        if DRY_RUN:
            print(f"  [DRY RUN] Would update name: '{data.get('name')}' ‚Üí '{project_name}'")
            return True
        data['name'] = project_name
        data['description'] = f"Project: {project_name}"
        with open('package.json', 'w') as f:
            json.dump(data, f, indent=2)
            f.write('\n')
        print(f"  ‚úì Updated package.json")
        return True
    except Exception as e:
        print(f"  ‚ö† Error updating package.json: {e}")
        return False

def update_project_files(project_name):
    """Update all project files with new project name"""
    print(f"üìù Updating project files...")
    replacements = get_replacement_patterns(project_name)
    files = [
        'AGENTS.md', 'Dockerfile', 'Makefile', 'README.md',
        'docker-compose.dev.yml', 'docker-compose.test.yml',
        'docs/secrets.md', 'package-lock.json',
        'sonar-project.properties', 'src/apps/frontend/index.html',
    ]
    # Add config, workflow, test, and backend files if they exist
    for pattern in ['config/*.yml', '.github/workflows/*.yml', 'tests/**/*.py', 'src/apps/backend/**/*.py']:
        files.extend(glob.glob(pattern, recursive=True))
    
    updated = sum(1 for f in files if os.path.exists(f) and replace_in_file(f, replacements))
    print(f"  ‚úì Updated {updated} files")
    return updated > 0

def get_template_repo():
    """Get template repository from git remote"""
    result = run_command(['git', 'remote', 'get-url', 'origin'], check=False, use_shell=False)
    if result.returncode == 0:
        url = result.stdout.strip()
        if 'github.com' in url:
            parts = url.replace('https://github.com/', '').replace('git@github.com:', '').replace('.git', '').split('/')
            if len(parts) >= 2:
                return f"{parts[0]}/{parts[1]}"
    print("  ‚úó Could not detect template repository")
    sys.exit(1)

def create_and_clone_repo(project_name, org=None, is_public=False):
    """Create GitHub repository from template and clone it"""
    parent_dir = os.path.dirname(os.getcwd())
    new_dir = os.path.join(parent_dir, project_name)
    
    if os.path.exists(new_dir):
        print(f"‚úó Directory '{new_dir}' already exists")
        sys.exit(1)
    
    repo_name = f"{org}/{project_name}" if org else project_name
    template_repo = get_template_repo()
    visibility = 'public' if is_public else 'private'
    
    print(f"üêô Creating {visibility} repository from template...")
    print(f"  Template: {template_repo}")
    print(f"  New repo: {repo_name}")
    
    if DRY_RUN:
        print(f"  [DRY RUN] Would create and clone repo")
        return f"https://github.com/{repo_name}", new_dir
    
    # Create repo from template (use list format to prevent injection)
    visibility_flag = '--public' if is_public else '--private'
    cmd = ['gh', 'repo', 'create', repo_name, '--template', template_repo, visibility_flag, '--confirm', '--clone=false']
    result = run_command(cmd, check=False, use_shell=False)
    if result.returncode != 0:
        if "already exists" in result.stderr.lower():
            print(f"  ‚úó Repository {repo_name} already exists")
        else:
            print(f"  ‚úó Failed: {result.stderr}")
        sys.exit(1)
    
    # Get repo URL
    url_cmd = ['gh', 'repo', 'view', repo_name, '--json', 'url', '-q', '.url']
    url_result = run_command(url_cmd, check=False, use_shell=False)
    repo_url = url_result.stdout.strip() if url_result.returncode == 0 else f"https://github.com/{repo_name}"
    print(f"  ‚úì Repository created: {repo_url}")
    
    # Clone repo with retry (GitHub template generation is async)
    print(f"\nüì• Cloning repository...")
    clone_cmd = ['git', 'clone', repo_url, new_dir]
    max_retries = 3
    for attempt in range(1, max_retries + 1):
        clone_result = run_command(clone_cmd, check=False, silent=True, use_shell=False)
        if clone_result.returncode == 0:
            break
        if attempt < max_retries:
            print(f"  ‚è≥ Waiting for template generation (attempt {attempt}/{max_retries})...")
            time.sleep(5)
        else:
            print(f"  ‚úó Failed to clone repository after {max_retries} attempts")
            if clone_result.stderr:
                print(f"  {clone_result.stderr}")
            sys.exit(1)
    
    print(f"  ‚úì Cloned to: {new_dir}")
    return repo_url, new_dir

def create_branch(branch_name):
    """Create and switch to a new branch"""
    if not os.path.exists('.git'):
        return False
    print(f"üåø Creating branch: {branch_name}...")
    if DRY_RUN:
        print(f"  [DRY RUN] Would run: git checkout -b {branch_name}")
        return True
    # Set git config if not set (only auto-configure in CI to avoid overriding user settings)
    if not run_command(['git', 'config', 'user.name'], check=False, silent=True, use_shell=False).stdout.strip():
        setup_name = os.environ.get('PROJECT_SETUP_GIT_NAME')
        if setup_name:
            run_command(['git', 'config', 'user.name', setup_name], check=False, use_shell=False)
        else:
            print("  ‚ö† Git user.name is not configured. Set PROJECT_SETUP_GIT_NAME env var or run 'git config user.name' manually.")
    if not run_command(['git', 'config', 'user.email'], check=False, silent=True, use_shell=False).stdout.strip():
        setup_email = os.environ.get('PROJECT_SETUP_GIT_EMAIL')
        if setup_email:
            run_command(['git', 'config', 'user.email', setup_email], check=False, use_shell=False)
        else:
            print("  ‚ö† Git user.email is not configured. Set PROJECT_SETUP_GIT_EMAIL env var or run 'git config user.email' manually.")
    result = run_command(['git', 'checkout', '-b', branch_name], check=False, use_shell=False)
    if result.returncode == 0:
        print(f"  ‚úì Branch created")
        return True
    return False

def commit_and_push(project_name, branch_name, repo_url):
    """Commit changes and push branch"""
    if not os.path.exists('.git'):
        return False, False, None
    
    # Commit
    print("üíæ Committing changes...")
    status_result = run_command(['git', 'status', '--porcelain'], check=False, use_shell=False)
    if status_result.stdout.strip():
        if DRY_RUN:
            print(f"  [DRY RUN] Would commit and push")
            return True, True, None
        run_command(['git', 'add', '.'], check=False, use_shell=False)
        msg = f"Setup {project_name} from template"
        commit_result = run_command(['git', 'commit', '-m', msg], check=False, use_shell=False)
        if commit_result.returncode == 0:
            print(f"  ‚úì Committed: {msg}")
        else:
            return False, False, None
    else:
        print("  ‚Ñπ No changes to commit")
        return False, False, None
    
    # Push
    print(f"üöÄ Pushing branch '{branch_name}'...")
    push_result = run_command(['git', 'push', '-u', 'origin', branch_name], check=False, use_shell=False)
    if push_result.returncode == 0:
        print(f"  ‚úì Branch pushed")
    else:
        return True, False, None
    
    # Create PR (only check base branch when creating PR)
    print(f"üìù Creating pull request...")
    base_check = run_command(['git', 'ls-remote', '--heads', 'origin', 'main'], check=False, silent=True, use_shell=False)
    base = "main" if base_check.stdout.strip() else "master"
    title = f"Setup {project_name} from template"
    body = f"""## Setup Project from Template

This PR sets up **{project_name}** from flask-react-template.

### Changes:
- ‚úÖ Updated project name throughout all files
- ‚úÖ Replaced template references
- ‚úÖ Updated package.json and config files

**Template:** flask-react-template
**New project:** {project_name}
"""
    pr_cmd = ['gh', 'pr', 'create', '--title', title, '--body', body, '--base', base, '--head', branch_name]
    result = run_command(pr_cmd, check=False, use_shell=False)
    if result.returncode == 0:
        pr_url = result.stdout.strip().split('\n')[-1]
        print(f"  ‚úì PR created: {pr_url}")
        return True, True, pr_url
    return True, True, None

def main():
    """Main execution function"""
    global DRY_RUN
    
    if len(sys.argv) < 2:
        print("Usage: ./project-setup <project_name> [organization] [--public] [--dry-run]")
        print("\nParameters:")
        print("  <project_name>   Name of the new project and GitHub repository")
        print("  [organization]   GitHub organization (default: jalantechnologies)")
        print("  --public         Create the repository as public (default: private)")
        print("  --dry-run        Show actions without making any changes")
        print("\nExamples:")
        print("  ./project-setup my-project")
        print("  ./project-setup my-project jalantechnologies --public --dry-run")
        sys.exit(1)
    
    args = sys.argv[1:]
    if '--dry-run' in args:
        DRY_RUN = True
        args.remove('--dry-run')
        print("="*60)
        print("üîç DRY RUN MODE - No changes will be made")
        print("="*60 + "\n")
    
    is_public = '--public' in args
    if is_public:
        args.remove('--public')
    
    project_name = args[0]
    org = args[1] if len(args) > 1 else 'jalantechnologies'
    original_dir = os.getcwd()
    
    # Validate
    is_valid, error = validate_project_name(project_name)
    if not is_valid:
        print(f"‚úó Invalid project name: {error}")
        sys.exit(1)
    
    # Check requirements
    print("üîç Checking requirements...")
    check_requirements()
    print("  ‚úì All requirements met\n")
    
    print(f"üöÄ Setting up project: {project_name}\n")
    
    # Create repo from template and clone
    repo_url, new_dir = create_and_clone_repo(project_name, org, is_public)
    if DRY_RUN:
        print(f"  [DRY RUN] Would change directory to: {new_dir}")
    else:
        try:
            os.chdir(new_dir)
        except OSError as e:
            print(f"‚úó Failed to change directory to {new_dir}: {e}")
            sys.exit(1)
    
    # Update files
    update_package_json(project_name)
    update_project_files(project_name)
    
    # Install dependencies
    print(f"üì• Installing dependencies...")
    if DRY_RUN:
        print("  [DRY RUN] Would run: npm install")
    elif os.path.exists('package.json'):
        result = run_command(['npm', 'install'], check=False, use_shell=False)
        if result.returncode != 0:
            print("  ‚ö† Warning: npm install failed. You may need to run it manually.")
    
    # Create branch, commit, push, and create PR
    branch_name = "setup-project-from-template"
    pr_url = None
    branch_created = create_branch(branch_name)
    if branch_created:
        committed, pushed, pr_url = commit_and_push(project_name, branch_name, repo_url)
    else:
        print(f"  ‚úó Failed to create branch '{branch_name}'. Skipping commit and push.")
    
    # Summary
    if DRY_RUN:
        print("\n" + "="*60)
        print("üîç DRY RUN COMPLETE - No changes were made")
        print("="*60)
        try:
            if os.path.isdir(original_dir):
                os.chdir(original_dir)
        except OSError:
            print(f"‚ö†Ô∏è Warning: Could not change back to original directory: {original_dir}")
    else:
        print("\n" + "="*60)
        print("‚úì Setup complete!")
        print("="*60)
        print(f"\nProject: {project_name}")
        print(f"Repository: {repo_url}")
        if pr_url:
            print(f"\n‚úÖ Pull Request Created: {pr_url}")
            print("‚è≥ Waiting for review and merge...")
        print(f"\nüìç Project location: {new_dir}")
        print(f"üìç Template location: {original_dir}\n")

if __name__ == "__main__":
    main()
