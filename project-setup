#!/usr/bin/env python3
"""Automate project setup from flask-react-template.

Creates a new private repository under the organization, applies naming
conventions across project files, and opens a pull request with the changes.

Usage:
    ./project-setup my-new-project
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
import re
import shlex
import shutil
import subprocess
import sys
import time
from typing import Sequence


DEFAULT_BRANCH_NAME = "setup-project-from-template"
DEFAULT_ORG = "jalantechnologies"
REPO_NAME_MAX_LEN = 100
TEMPLATE_REPO_FULL_NAME = "jalantechnologies/flask-react-template"

# File patterns to update with new project name
PROJECT_FILE_GLOBS = (
    ".github/workflows/*.yml", "AGENTS.md", "Dockerfile", "Makefile", "README.md",
    "config/*.yml", "docker-compose.dev.yml", "docker-compose.test.yml", "docs/secrets.md",
    "package-lock.json", "sonar-project.properties",
    "src/apps/backend/**/*.py", "src/apps/frontend/index.html",
    "tests/**/*.py",
)


class SetupError(RuntimeError):
    pass


def run(
    args: Sequence[str],
    *,
    check: bool = True,
    cwd: Path | None = None,
    quiet: bool = False,
) -> subprocess.CompletedProcess[str]:
    """Execute a shell command and optionally raise on failure.
    
    Args:
        args: Command and arguments to execute
        check: Raise SetupError if command fails
        cwd: Working directory for command execution
        quiet: Suppress command name in error messages
    """
    if not args:
        raise ValueError("Command args cannot be empty.")

    display = shlex.join(list(args))
    result = subprocess.run(
        list(args),
        capture_output=True,
        check=False,
        cwd=str(cwd) if cwd else None,
        text=True,
    )
    if check and result.returncode != 0:
        stderr = (result.stderr or "").strip()
        stdout = (result.stdout or "").strip()
        details = stderr or stdout or f"exit code {result.returncode}"
        if quiet:
            raise SetupError(details)
        raise SetupError(f"Failed to run: {display}\n{details}")
    return result

def replace_in_file(
    *,
    file_path: Path,
    replacements: Sequence[tuple[str, str]],
) -> bool:
    """Apply text replacements to a file.
    
    Returns:
        True if file was modified, False if unchanged or inaccessible
    """
    if not file_path.exists() or not file_path.is_file():
        return False

    try:
        content = file_path.read_text(encoding="utf-8")
    except (OSError, UnicodeDecodeError):
        return False

    updated = content
    for old, new in replacements:
        updated = updated.replace(old, new)

    if updated == content:
        return False

    try:
        file_path.write_text(updated, encoding="utf-8")
    except OSError:
        return False
    return True

def validate_project_name(project_name: str) -> None:
    """Validate project name meets GitHub repository naming requirements."""
    if not project_name.strip():
        raise SetupError("Project name cannot be empty. Try: `./project-setup my-project`.")
    if len(project_name) > REPO_NAME_MAX_LEN:
        raise SetupError(f"Project name is too long (max {REPO_NAME_MAX_LEN} characters).")
    if project_name.startswith(".") or project_name.endswith(".") or ".." in project_name:
        raise SetupError("Project name cannot start/end with '.' or contain consecutive dots ('..').")
    if not re.fullmatch(r"[a-zA-Z0-9._-]+", project_name):
        raise SetupError(
            "Project name contains invalid characters. Allowed: letters, numbers, '.', '_', '-'."
        )

def ensure_requirements() -> None:
    """Verify required CLI tools are installed and GitHub CLI is authenticated."""
    required_tools = ["gh", "git", "npm"]

    missing = [tool for tool in required_tools if shutil.which(tool) is None]
    if missing:
        raise SetupError(f"Missing required tools: {', '.join(missing)}. Install them and try again.")

    auth = run(["gh", "auth", "status"], check=False, quiet=True)
    if auth.returncode != 0:
        raise SetupError("GitHub CLI is not authenticated. Run `gh auth login` and try again.")

def get_replacement_patterns(project_name: str) -> list[tuple[str, str]]:
    """Generate naming convention replacements for all file patterns.
    
    Converts project name to various conventions:
    - UPPER_CASE: FLASK-REACT-TEMPLATE
    - Title Case: Flask React Template
    - PascalCase: FlaskReactTemplate
    - kebab-case: flask-react-template
    - camelCase: flaskReactTemplate
    - snake_case: flask_react_template
    """
    snake = re.sub(r"[-]+", "_", project_name)
    words = [w for w in re.split(r"[-_]+", project_name) if w]
    pascal = "".join(word[:1].upper() + word[1:] for word in words) if words else project_name
    lower_camel = pascal[:1].lower() + pascal[1:] if pascal else project_name

    return [
        ("FLASK-REACT-TEMPLATE", project_name.upper()),
        ("Flask React Template", project_name),
        ("FlaskReactTemplate", pascal),
        ("flask-react-template", project_name.lower()),
        ("flaskReactTemplate", lower_camel),
        ("flask_react_template", snake),
    ]

def update_package_json(*, project_name: str, repo_dir: Path) -> None:
    """Update package.json with new project name and description."""
    package_json_path = repo_dir / "package.json"
    if not package_json_path.exists():
        return

    data = json.loads(package_json_path.read_text(encoding="utf-8"))
    data["description"] = f"Project: {project_name}"
    data["name"] = project_name

    package_json_path.write_text(json.dumps(data, indent=2) + "\n", encoding="utf-8")

def update_project_files(*, project_name: str, repo_dir: Path) -> int:
    """Apply naming convention replacements across all project files.
    
    Returns:
        Number of files successfully updated
    """
    replacements = get_replacement_patterns(project_name)
    updated_count = 0
    for pattern in PROJECT_FILE_GLOBS:
        for path in repo_dir.glob(pattern):
            if path.is_file() and replace_in_file(file_path=path, replacements=replacements):
                updated_count += 1
    return updated_count

def clone_repo_with_retry(*, clone_dir: Path, repo_url: str) -> None:
    """Clone repository with retry logic.
    
    GitHub template repos may not be immediately available after creation.
    Retries up to 3 times with 5-second delays between attempts.
    """
    for attempt in range(1, 4):
        result = run(["git", "clone", repo_url, clone_dir.as_posix()], check=False)
        if result.returncode == 0:
            return
        if attempt < 3:
            print(f"Waiting for template generation ({attempt}/3)... retrying in 5s")
            time.sleep(5)
            continue
        raise SetupError(f"Failed to clone after 3 attempts. Try again or run: `git clone {repo_url}`")

def ensure_git_identity_configured(*, repo_dir: Path) -> None:
    """Verify git user.name and user.email are configured."""
    name = run(["git", "config", "user.name"], check=False, cwd=repo_dir, quiet=True).stdout.strip()
    email = run(["git", "config", "user.email"], check=False, cwd=repo_dir, quiet=True).stdout.strip()
    if name and email:
        return
    raise SetupError(
        "Git author identity is not configured.\n"
        "Run:\n"
        "  git config --global user.name \"Your Name\"\n"
        "  git config --global user.email \"you@example.com\""
    )


def has_uncommitted_changes(*, repo_dir: Path) -> bool:
    status = run(["git", "status", "--porcelain"], check=True, cwd=repo_dir, quiet=True)
    return bool(status.stdout.strip())


def create_pr(
    *,
    base_branch: str,
    branch_name: str,
    project_name: str,
    repo_dir: Path,
) -> str | None:
    """Create a pull request for the setup changes.
    
    Returns:
        PR URL if successful, None otherwise
    """
    title = f"Setup {project_name} from template"
    body = f"Sets up **{project_name}** from **{TEMPLATE_REPO_FULL_NAME}** (phase 1: template + PR)."
    result = run(
        [
            "gh",
            "pr",
            "create",
            "--title",
            title,
            "--body",
            body,
            "--base",
            base_branch,
            "--head",
            branch_name,
        ],
        check=False,
        cwd=repo_dir,
    )
    if result.returncode != 0:
        return None
    return result.stdout.strip().splitlines()[-1].strip() if result.stdout.strip() else None


def npm_install(*, repo_dir: Path) -> None:
    """Install npm dependencies in the cloned repository."""
    if not (repo_dir / "package.json").exists():
        return
    result = run(["npm", "install"], check=False, cwd=repo_dir)
    if result.returncode != 0:
        raise SetupError("`npm install` failed. Fix the error and rerun the script.")


def parse_args(argv: Sequence[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        prog="project-setup",
        description=f"Create a private repo under {DEFAULT_ORG} from this template and open a PR.",
    )
    parser.add_argument("project_name", help="New GitHub repository name (e.g. my-project)")
    return parser.parse_args(list(argv))


def create_repo_from_template(
    *,
    project_name: str,
    template_dir: Path,
) -> tuple[Path, str, str]:
    """Create a new private repository from the template.
    
    Returns:
        Tuple of (local_clone_path, repo_url, base_branch_name)
    """
    clone_dir = template_dir.parent / project_name
    if clone_dir.exists():
        raise SetupError(f"Directory already exists: {clone_dir.as_posix()}\nChoose a different name.")

    repo_full_name = f"{DEFAULT_ORG}/{project_name}"
    repo_url = f"https://github.com/{repo_full_name}"

    result = run(
        [
            "gh",
            "repo",
            "create",
            repo_full_name,
            "--template",
            TEMPLATE_REPO_FULL_NAME,
            "--private",
            "--confirm",
            "--clone=false",
        ],
        check=False,
    )
    if result.returncode != 0:
        stderr = (result.stderr or "").strip()
        if "already exists" in stderr.lower():
            raise SetupError(f"Repository already exists: {repo_full_name}\nPick a new project name.")
        raise SetupError(f"Failed to create repo from template.\n{stderr or 'Unknown error.'}")

    base_branch = run(
        ["gh", "repo", "view", repo_full_name, "--json", "defaultBranchRef", "-q", ".defaultBranchRef.name"],
        check=False,
        cwd=template_dir,
        quiet=True,
    ).stdout.strip() or "main"

    clone_repo_with_retry(repo_url=repo_url, clone_dir=clone_dir)
    return clone_dir, repo_url, base_branch


def run_setup(args: argparse.Namespace) -> tuple[str, str | None, Path]:
    """Execute the complete project setup workflow."""
    project_name = str(args.project_name)
    validate_project_name(project_name)
    ensure_requirements()

    template_dir = Path.cwd()
    
    # Step 1: Create repository from template
    print(f"Creating private repository under {DEFAULT_ORG}...")
    clone_dir, repo_url, base_branch = create_repo_from_template(
        project_name=project_name,
        template_dir=template_dir
    )

    # Step 2: Update project files with new name
    updated_files = update_all_project_files(project_name=project_name, repo_dir=clone_dir)
    print(f"Updated {updated_files} file(s).")

    # Step 3: Install dependencies
    print("Installing npm dependencies...")
    npm_install(repo_dir=clone_dir)

    # Step 4: Commit and push changes
    commit_and_push_changes(project_name=project_name, repo_dir=clone_dir)

    # Step 5: Create pull request
    pr_url = create_pr(
        base_branch=base_branch,
        branch_name=DEFAULT_BRANCH_NAME,
        project_name=project_name,
        repo_dir=clone_dir,
    )
    
    return repo_url, pr_url, clone_dir


def update_all_project_files(*, project_name: str, repo_dir: Path) -> int:
    """Update package.json and all project files with new project name.
    
    Returns:
        Number of files updated
    """
    update_package_json(project_name=project_name, repo_dir=repo_dir)
    return update_project_files(project_name=project_name, repo_dir=repo_dir)


def commit_and_push_changes(*, project_name: str, repo_dir: Path) -> None:
    """Create a new branch, commit changes, and push to remote."""
    ensure_git_identity_configured(repo_dir=repo_dir)
    run(["git", "checkout", "-b", DEFAULT_BRANCH_NAME], check=True, cwd=repo_dir)

    if not has_uncommitted_changes(repo_dir=repo_dir):
        raise SetupError("No changes detected after template update. Nothing to PR.")

    run(["git", "add", "."], check=True, cwd=repo_dir)
    run(["git", "commit", "-m", f"Setup {project_name} from template"], check=True, cwd=repo_dir)
    run(["git", "push", "-u", "origin", DEFAULT_BRANCH_NAME], check=True, cwd=repo_dir)


def main() -> int:
    try:
        args = parse_args(sys.argv[1:])
        repo_url, pr_url, clone_dir = run_setup(args)
        print("\n" + "=" * 60)
        print("Setup complete")
        print("=" * 60)
        print(f"Project: {args.project_name}")
        print(f"Repository: {repo_url}")
        if pr_url:
            print(f"Pull request: {pr_url}")
        print(f"Location: {clone_dir.as_posix()}")
        return 0
    except SetupError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    raise SystemExit(main())
